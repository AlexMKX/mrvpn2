---
# MRVPN2 CI/CD Fast Deployment Playbook
# Optimized playbook for automatic deployment via GitLab CI/CD

- name: Fast Deploy MRVPN2 VPN Infrastructure via CI/CD
  hosts: all
  become: true
  gather_facts: true
  any_errors_fatal: true
  max_fail_percentage: 0

  vars_files:
    - deployment-config.yml
    - mrvpn_config.yml

  vars:
    # CI/CD variables
    ci_commit_ref_name: "{{ lookup('env', 'CI_COMMIT_REF_NAME') | default('main', true) }}"
    ci_commit_sha: "{{ lookup('env', 'CI_COMMIT_SHA') | default('', true) }}"
    ci_pipeline_id: "{{ lookup('env', 'CI_PIPELINE_ID') | default('', true) }}"
    deployment_timestamp: "{{ lookup('env', 'DEPLOYMENT_TIMESTAMP') | default(lookup('pipe', 'date +%Y%m%d_%H%M%S'), true) }}"
    deploy_environment: "{{ lookup('env', 'DEPLOY_ENVIRONMENT') | default('production', true) }}"
    force_recreate: "{{ lookup('env', 'FORCE_RECREATE') | default(false, true) }}"
    clean_run: "{{ lookup('env', 'CLEAN_RUN') | default(false, true) }}"

    # Override variables for CI/CD
    deployment_config: "{{ deployment_config | combine({
      'deployment': deployment_config.deployment | combine({
        'force_redeploy': force_recreate,
        'clean_run': clean_run
      })
    }) }}"

  pre_tasks:
    - name: Display deployment information
      debug:
        msg: |
          MRVPN2 CI/CD Fast Deployment
          =================================

          Environment: {{ deploy_environment }}
          Pipeline: {{ ci_pipeline_id }}
          Commit: {{ ci_commit_sha | truncate(8, True, '') }}
          Branch: {{ ci_commit_ref_name }}
          Timestamp: {{ deployment_timestamp }}

          Target Servers:
          {% for host in ansible_play_hosts %}
            â€¢ {{ host }} ({{ hostvars[host].ansible_host }})
          {% endfor %}

          Services to deploy:
            â€¢ Firezone: {{ deployment_config.services.firezone.deploy | ternary('ENABLED', 'DISABLED') }}
            â€¢ WireGuard: {{ deployment_config.services.wireguard.deploy | ternary('ENABLED', 'DISABLED') }}

          Options:
            â€¢ Force recreate: {{ force_recreate | ternary('YES', 'NO') }}
            â€¢ Clean run: {{ clean_run | ternary('YES', 'NO') }}
      run_once: true

    - name: Validate deployment configuration
      assert:
        that:
          - deployment_config is defined
          - mrvpn_config is defined
        fail_msg: "Missing required configuration files"
      run_once: true

    - name: Validate required environment variables
      assert:
        that:
          - lookup('env', 'VPN_MAIN_IP') | length > 0
          - lookup('env', 'VPN_EXIT_IPS') | length > 0
          - lookup('env', 'ANSIBLE_USER') | length > 0
        fail_msg: "Missing required environment variables: VPN_MAIN_IP, VPN_EXIT_IPS, ANSIBLE_USER"
      run_once: true

    - name: Create deployment marker file
      file:
        path: "/opt/.mrvpn_deployment_{{ deployment_timestamp }}"
        state: touch
        mode: '0644'
      run_once: true
      delegate_to: localhost

    - name: Create MRVPN base directory
      file:
        path: "{{ mrvpn_config.mrvpn_base_dir }}"
        state: directory
        mode: '0755'

    # Fast Docker installation (optimized for CI/CD)
    - name: Install Docker (Fast CI/CD Version)
      block:
        - name: Check if Docker is installed
          shell: |
            if command -v docker >/dev/null 2>&1; then
              echo "DOCKER_EXISTS=yes"
              docker --version
            else
              echo "DOCKER_EXISTS=no"
            fi
          register: docker_check
          ignore_errors: yes

        - name: Install Docker (Ubuntu/Debian)
          shell: |
            set -e
            echo "ðŸ“¦ Installing Docker..."

            # Update package list
            apt-get update -qq

            # Install prerequisites
            apt-get install -y -qq apt-transport-https ca-certificates curl gnupg lsb-release

            # Add Docker GPG key
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

            # Add Docker repository
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null

            # Update and install Docker
            apt-get update -qq
            apt-get install -y -qq docker-ce docker-ce-cli containerd.io

            echo "Docker installed successfully"
          when: ansible_os_family == 'Debian' and (docker_check.stdout is not defined or "DOCKER_EXISTS=no" in docker_check.stdout)
          ignore_errors: yes

        - name: Install Docker (CentOS/RHEL)
          shell: |
            set -e
            echo "ðŸ“¦ Installing Docker..."

            # Install prerequisites
            yum install -y -q yum-utils device-mapper-persistent-data lvm2

            # Add Docker repository
            yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

            # Install Docker
            yum install -y -q docker-ce docker-ce-cli containerd.io

            echo "Docker installed successfully"
          when: ansible_os_family == 'RedHat' and (docker_check.stdout is not defined or "DOCKER_EXISTS=no" in docker_check.stdout)
          ignore_errors: yes

    - name: Start Docker service (Fast version)
      block:
        - name: Start Docker via systemd
          systemd:
            name: docker
            state: started
            enabled: yes
            daemon_reload: yes
          ignore_errors: yes

        - name: Start Docker via service
          shell: service docker start || /etc/init.d/docker start || echo "Failed to start Docker"
          ignore_errors: yes

        - name: Manual Docker daemon start
          shell: |
            if ! docker info >/dev/null 2>&1; then
              dockerd --host unix:///var/run/docker.sock --host tcp://0.0.0.0:2376 &
              sleep 5
            fi
          ignore_errors: yes
      when: docker_check.stdout is defined and "DOCKER_EXISTS=yes" in docker_check.stdout

    - name: Add user to docker group
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes
      when: ansible_user != 'root'
      ignore_errors: yes

    - name: Install Docker Compose v2
      shell: |
        set -e
        echo "ðŸ“¦ Installing Docker Compose v2..."

        # Check if compose v2 exists
        if ! docker compose version >/dev/null 2>&1; then
          # Detect architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64) ARCH="x86_64" ;;
            aarch64) ARCH="aarch64" ;;
            armv7l) ARCH="armv7" ;;
            *) ARCH="x86_64" ;;
          esac

          # Install Docker Compose v2 plugin
          mkdir -p /usr/local/lib/docker/cli-plugins
          curl -SL https://github.com/docker/compose/releases/download/v2.33.1/docker-compose-linux-${ARCH} -o /usr/local/lib/docker/cli-plugins/docker-compose
          chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
          echo "Docker Compose v2 installed"
        else
          echo "Docker Compose v2 already exists"
        fi
      ignore_errors: yes

    - name: Final Docker verification
      shell: |
        echo "Final Docker Check..."
        echo "Docker version: $(docker --version 2>/dev/null || echo 'NOT FOUND')"
        echo "Docker Compose version: $(docker compose version 2>/dev/null || echo 'NOT FOUND')"
        echo "Docker daemon: $(docker info >/dev/null 2>&1 && echo 'RUNNING' || echo 'NOT RUNNING')"

        if docker info >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
          echo "Docker and Docker Compose: READY"
          exit 0
        else
          echo "Docker or Docker Compose: NOT READY"
          exit 1
        fi
      register: final_docker_check
      ignore_errors: yes

    - name: Fail if Docker is not working
      fail:
        msg: "Docker daemon is not running on {{ inventory_hostname }}. Cannot proceed with deployment."
      when: final_docker_check.rc != 0

    # Firewall configuration
    - name: Remove incorrect WireGuard port rules (TCP 51820)
      ufw:
        rule: deny
        port: "51820"
        proto: tcp
        delete: yes
      ignore_errors: yes

    - name: Configure UFW firewall TCP rules
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - "22"    # SSH
        - "443"   # HTTPS
        - "80"    # HTTP
      ignore_errors: yes

    - name: Configure WireGuard UFW rule (UDP 51620)
      ufw:
        rule: allow
        port: "51620"
        proto: udp
      ignore_errors: yes

    - name: Enable UFW firewall
      ufw:
        state: enabled
        policy: deny
      ignore_errors: yes

    # Extract Firezone variables
    - name: Extract Firezone variables
      set_fact:
        fz_server_url: "{{ mrvpn_config.firezone.fz_server_url }}"
        fz_client_subnet: "{{ mrvpn_config.firezone.fz_client_subnet }}"
        fz_client_gateway: "{{ mrvpn_config.firezone.fz_client_gateway }}"
        fz_client_allowed_subnets: "{{ mrvpn_config.firezone.fz_client_allowed_subnets }}"
        fz_oidc: "{{ mrvpn_config.firezone.fz_oidc }}"
        fz_firezone_dir: "{{ mrvpn_config.mrvpn_base_dir }}/firezone"
        fz_admin: "{{ lookup('env', 'FZ_ADMIN_EMAIL') | default(mrvpn_config.firezone.fz_admin, true) }}"
        fz_wireguard_port: "{{ lookup('env', 'FZ_WIREGUARD_PORT') | default(mrvpn_config.firezone.fz_wireguard_port, true) }}"
        fz_admin_password: "{{ lookup('env', 'FZ_ADMIN_PASS') }}"
        mrvpn_firezone: "{{ mrvpn_config.firezone | combine({
          'fz_admin': lookup('env', 'FZ_ADMIN_EMAIL') | default(mrvpn_config.firezone.fz_admin, true),
          'fz_admin_password': lookup('env', 'FZ_ADMIN_PASS'),
          'fz_wireguard_port': lookup('env', 'FZ_WIREGUARD_PORT') | default(mrvpn_config.firezone.fz_wireguard_port, true)
        }) }}"
      when: deployment_config.services.firezone.deploy

    # Validate Firezone configuration
    - name: Validate Firezone configuration
      assert:
        that:
          - fz_admin is defined and fz_admin != ""
          - fz_wireguard_port is defined and fz_wireguard_port != ""
          - fz_admin_password is defined and fz_admin_password != ""
        fail_msg: "Firezone configuration is incomplete"
      when: deployment_config.services.firezone.deploy
      run_once: true

    # Extract WireGuard variables
    - name: Extract WireGuard variables
      set_fact:
        wg_tunnel_config: "{{ mrvpn_config.tunnels.wg_exit1 }}"
        wg_base_dir: "{{ mrvpn_config.mrvpn_base_dir }}/wireguard"
        wg_tunnel_name: "wg_exit1"
      when: deployment_config.services.wireguard.deploy and mrvpn_config.tunnels.wg_exit1 is defined

  roles:
    - role: docker-wireguard
      vars:
        wg_tunnel_config: "{{ wg_tunnel_config }}"
        wg_base_dir: "{{ wg_base_dir }}"
        wg_tunnel_name: "{{ wg_tunnel_name }}"
      when: deployment_config.services.wireguard.deploy and wg_tunnel_config is defined

    - role: mrvpn2
      vars:
        mrvpn_root: "{{ mrvpn_config.mrvpn_base_dir }}"
        entrypoint: "{{ mrvpn_config.entrypoint }}"
        mrvpn_tunnels: "{{ mrvpn_config.tunnels }}"
        mrvpn_routing: "{{ mrvpn_config.routing }}"
        mrvpn_services: "{{ mrvpn_config.services }}"
        mrvpn_firezone: "{{ mrvpn_firezone }}"
      when: deployment_config.services.firezone.deploy or deployment_config.services.wireguard.deploy

  post_tasks:
    - name: Wait for services to be ready
      pause:
        seconds: 30
      run_once: true

    - name: Verify Firezone is accessible
      uri:
        url: "{{ mrvpn_config.firezone.fz_server_url }}"
        validate_certs: false
        timeout: 30
      register: firezone_check
      until: firezone_check.status == 200
      retries: 6
      delay: 10
      when: deployment_config.services.firezone.deploy
      ignore_errors: yes

    - name: Check running containers
      shell: |
        echo "Checking running containers..."
        docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
      register: containers_check
      ignore_errors: yes

    - name: Display deployment summary
      debug:
        msg: |
          MRVPN2 CI/CD Deployment Complete!
          =====================================

          Deployment Details:
          â€¢ Environment: {{ deploy_environment }}
          â€¢ Pipeline: {{ ci_pipeline_id }}
          â€¢ Commit: {{ ci_commit_sha | truncate(8, True, '') }}
          â€¢ Timestamp: {{ deployment_timestamp }}

          Services Status:
          â€¢ Firezone: {{ deployment_config.services.firezone.deploy | ternary(
              (firezone_check.status == 200) | ternary('RUNNING', 'STARTING'),
              'NOT DEPLOYED') }}
          â€¢ WireGuard: {{ deployment_config.services.wireguard.deploy | ternary('DEPLOYED', 'NOT DEPLOYED') }}

          Access Information:
          â€¢ Firezone Admin: {{ mrvpn_config.firezone.fz_server_url }}
          â€¢ Admin User: {{ fz_admin | default('N/A') }}
          â€¢ WireGuard Port: {{ mrvpn_config.tunnels.wg_exit1.hosts.exit1_vpn_tehinkome_ru.expose | default('N/A') }}

          Running Containers:
          {{ containers_check.stdout | default('No containers found') }}

          Next Steps:
          1. Access {{ mrvpn_config.firezone.fz_server_url }} in your browser
          2. Login with admin credentials
          3. Configure OIDC providers (Google/Yandex)
          4. Create VPN users and policies
          5. Download WireGuard configurations
      run_once: true

    - name: Send deployment notification
      debug:
        msg: |
           Deployment Notification
          ========================

          VPN Infrastructure Successfully Deployed!

          Details:
          â€¢ Project: MRVPN2
          â€¢ Environment: {{ deploy_environment }}
          â€¢ Pipeline: {{ ci_pipeline_id }}
          â€¢ Commit: {{ ci_commit_sha | truncate(8, True, '') }}
          â€¢ Timestamp: {{ deployment_timestamp }}

          Access:
          â€¢ URL: {{ mrvpn_config.firezone.fz_server_url }}
          â€¢ Admin: {{ fz_admin | default('N/A') }}

          Status: All services deployed and verified
      run_once: true
      when: firezone_check.status == 200 or deployment_config.services.wireguard.deploy
