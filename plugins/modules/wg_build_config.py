#!/usr/bin/python
"""
WireGuard Configuration Builder Module
This module creates mesh WireGuard configurations where all peers connect to each other,
generating private/public keys, setting up peer configurations, and handling network addressing.
Supports various configuration options including expose settings, allowed networks, and routing.
"""

import logging

ANSIBLE_METADATA = {
    'metadata_version': '0.2',
    'status': ['preview'],
    'supported_by': 'alexmkx'

}

DOCUMENTATION = """
---
module: wg_build_config
short_description: Builds a mesh WireGuard configuration
description:
  - This module creates a mesh WireGuard configuration where all peers connect to each other.
  - It generates private and public keys, sets up peer configurations, and handles network addressing.
  - The module supports various configuration options including expose settings, allowed networks, and more.
version_added: "0.2"
author: "alexmkx"
options:
  tunnel:
    description:
      - A dictionary containing the tunnel configuration.
    required: true
    type: dict
  suboptions:
    subnet:
      description:
        - The subnet to be used for the WireGuard network.
      required: true
      type: str
    hosts:
      description:
        - A dictionary of hosts to be included in the WireGuard network.
      required: true
      type: dict
      suboptions:
        expose:
          description:
            - Specifies how the host should be exposed.
            - Can be a string in the format "IP:PORT" or just "PORT".
            - Can also be an integer representing just the port.
            - If only a port is specified (either as string or integer), the 'hostvars' parameter must be provided to infer the host IP.
            - If not specified, the host will not be exposed (i.e., it will only act as a client).
          required: false
          type: raw
        allowed_nets:
          description:
            - A list of networks that this host is allowed to access.
          required: false
          type: list
          elements: str
        # ... other host-specific options ...
hostvars:
  description:
    - A dictionary containing host variables, typically the Ansible hostvars.
    - Required if any host's 'expose' is specified as just a port (string or integer) to infer the host IP.
  required: false
  type: dict
requirements:
- python >= 3.6
- wireguard-tools
notes:
- This module requires the 'wg' command to be available on the system for generating keys.
- The module uses the subprocess module to execute shell commands, ensure proper permissions are set.
- When specifying 'expose' for a host, you have several options:
  1. Full specification: "IP:PORT" (e.g., "203.0.113.1:51620")
  2. Port only as string: "PORT" (e.g., "51620")
  3. Port only as integer: 51620
- If specifying only a port (options 2 or 3), you must provide the 'hostvars' parameter so the module can infer the host IP from 'ansible_host'.
- If 'expose' is not specified for a host, that host will not be exposed and will only act as a client in the WireGuard network.
seealso:
  - name: WireGuard
    description: Official WireGuard website
    link: https://www.wireguard.com/
  - name: Ansible Networking Guide
    description: Ansible documentation for networking modules
    link: https://docs.ansible.com/ansible/latest/network/index.html
"""

EXAMPLES = '''
- name: Create WireGuard mesh configuration with various expose options
  wg_build_config:
    tunnel:
      subnet: "10.8.19.0/24"
      hosts:
        host1:
          expose: "203.0.113.1:51620"  # Full IP:PORT specification
        host2:
          expose: "51821"  # Port only as string, IP will be inferred from hostvars
        host3:
          expose: 51822  # Port only as integer, IP will be inferred from hostvars
        host4:
          # No expose specified, this host will only act as a client
          allowed_nets: 
            - 10.0.0.0/8
    hostvars: "{{ hostvars }}"
  register: wg_config

- name: Display WireGuard configuration
  debug:
    var: wg_config.result
'''

RETURN = '''
status:
  description: The status code of the operation.
  returned: always
  type: int
  sample: 200
changed:
  description: Indicates if the module made any changes.
  returned: always
  type: bool
  sample: true
result:
  description: The complete WireGuard configuration generated by the module.
  returned: on success
  type: dict
  contains:
    subnet:
      description: The subnet used for the WireGuard network.
      type: str
      sample: "10.8.19.0/24"
    hosts:
      description: Configuration details for each host in the WireGuard network.
      type: dict
      contains:
        wg_config:
          description: WireGuard-specific configuration for the host.
          type: dict
          contains:
            address:
              description: The IP address assigned to the host within the WireGuard network.
              type: str
              sample: "10.8.19.1"
            private:
              description: The private key for the host.
              type: str
            public:
              description: The public key for the host.
              type: str
            ip:
              description: The IP address where the host is reachable (if exposed).
              type: str
            port:
              description: The port where the host is reachable (if exposed).
              type: str
            peers:
              description: Configuration for each peer of this host.
              type: dict
              contains:
                public:
                  description: The public key of the peer.
                  type: str
                endpoint:
                  description: The endpoint (IP:port) of the peer.
                  type: str
                psk:
                  description: The pre-shared key for this peer connection.
                  type: str
                allowed_ips:
                  description: The allowed IPs for this peer.
                  type: str
                allowed_nets:
                  description: The allowed networks for this peer.
                  type: list
                  elements: str
'''

from ansible.module_utils.basic import AnsibleModule


def gen_psk() -> str:
    """
    Generate a preshared key (PSK) using the WireGuard utility.

    :return: The generated preshared key as a string.
    """
    import subprocess
    return subprocess.run("wg genpsk", shell=True, capture_output=True, text=True, check=True).stdout.rstrip()


def build_config(tunnel: dict, hostvars: dict) -> dict:
    """
    Build a configuration for a tunnel.

    :param tunnel: A dictionary representing the tunnel configuration.
    :param hostvars: A dictionary containing host variables.

    :return: The modified tunnel configuration dictionary
    """

    import os, subprocess, ipaddress, itertools
    # from collections import defaultdict
    # import pydevd_pycharm
    # pydevd_pycharm.settrace('localhost', port=12346, stdoutToServer=True, stderrToServer=True)

    hosts = list(tunnel['hosts'].keys())
    host_num = 1
    # generate keys and basic configs
    for hk, hv in tunnel['hosts'].items():
        wg_config = {}
        # define host ip within tunnel subnet
        wg_config['address'] = str(ipaddress.ip_network(tunnel['subnet']).network_address + host_num)
        # generate private and public keys
        if 'private' not in hv:
            private = subprocess.run("wg genkey", shell=True, capture_output=True, text=True, check=True).stdout.rstrip()
        else:
            private = hv['private'].rstrip()

        public = subprocess.run(f"echo '{private}' | wg pubkey", shell=True, capture_output=True, text=True, check=True).stdout.rstrip()
        wg_config['private'] = private
        wg_config['public'] = public
        if "expose" in hv:
            if isinstance(hv['expose'], int):
                # If expose is an integer, treat it as port only
                ansible_host = hostvars.get(hk, {}).get('ansible_host', '')
                port = str(hv['expose'])
                if ansible_host:
                    hv['expose'] = f"{ansible_host}:{hv['expose']}"
                    ip_port = [ansible_host, port]
                else:
                    raise ValueError(f"Host {hk} has no ansible_host and only port is provided")
            else:
                ip_port = str(hv['expose']).split(':')
                if len(ip_port) == 1:
                    # If only port is provided as string, use ansible_host from hostvars
                    ansible_host = hostvars.get(hk, {}).get('ansible_host', '')
                    if ansible_host:
                        hv['expose'] = f"{ansible_host}:{ip_port[0]}"
                        ip_port = [ansible_host, ip_port[0]]
                    else:
                        raise ValueError(f"Host {hk} has no ansible_host and no IP address provided")
            wg_config['ip'] = ip_port[0]
            wg_config['port'] = ip_port[1]
        host_num += 1
        tunnel['hosts'][hk]['wg_config'] = wg_config

    psk = {tuple(sorted((a, b))): gen_psk() for a, b in itertools.product(hosts, hosts) if a != b}
    # Generate peer configs
    for host, host_val in tunnel['hosts'].items():
        tunnel['hosts'][host]['wg_config']['peers'] = {}

        for peer, peer_val in tunnel['hosts'].items():
            if host != peer:
                peer_config = {k: v for k, v in peer_val.copy().items()
                               if k not in ['peers', 'private', 'wg_config']}
                peer_config['public'] = tunnel['hosts'][peer]['wg_config']['public']
                if 'expose' in tunnel['hosts'][peer]:
                    expose = tunnel['hosts'][peer]['expose']
                    if isinstance(expose, int):
                        # If expose is an integer, treat it as port only
                        ansible_host = hostvars.get(peer, {}).get('ansible_host', '')
                        if ansible_host:
                            peer_config['endpoint'] = f"{ansible_host}:{expose}"
                        else:
                            raise ValueError(f"Peer {peer} has no ansible_host and only port is provided")
                    else:
                        expose_parts = str(expose).split(':')
                        if len(expose_parts) == 1:
                            # If only port is provided as string, use ansible_host from hostvars
                            ansible_host = hostvars.get(peer, {}).get('ansible_host', '')
                            if ansible_host:
                                peer_config['endpoint'] = f"{ansible_host}:{expose_parts[0]}"
                            else:
                                raise ValueError(f"Peer {peer} has no ansible_host and no IP address provided")
                        else:
                            peer_config['endpoint'] = expose

                if 'psk' not in peer_config:
                    peer_config['psk'] = psk[tuple(sorted((host, peer)))]
                allowed_nets = [tunnel['hosts'][peer]['wg_config']['address']]
                if 'allowed_nets' in tunnel['hosts'][peer]:
                    allowed_nets.extend(tunnel['hosts'][peer]['allowed_nets'])
                ipr = [ipaddress.ip_network(x) for x in allowed_nets]
                peer_config['allowed_ips'] = ", ".join(
                    [str(x) for x in list(ipaddress.collapse_addresses(ipr))])
                peer_config['allowed_nets'] = [str(x) for x in
                                               list(ipaddress.collapse_addresses(ipr))]
                tunnel['hosts'][host]['wg_config']['peers'][peer] = peer_config

    return tunnel


def main():
    """ Main function to provide wireguard config build functionality as an Ansible module."""
    args = dict(
        tunnel=dict(type='dict',
                    required=True),
        hostvars=dict(type='dict',
                      required=False)
    )
    ansible = AnsibleModule(
        argument_spec=args,
        supports_check_mode=True)

    tunnel = ansible.params['tunnel']
    hostvars = ansible.params.get('hostvars', {})
    
    # Input validation
    if not isinstance(tunnel, dict) or not tunnel:
        ansible.fail_json(msg="Tunnel configuration must be a non-empty dictionary")
        
    if 'subnet' not in tunnel:
        ansible.fail_json(msg="Tunnel configuration must include 'subnet' key")
        
    if 'hosts' not in tunnel or not tunnel['hosts']:
        ansible.fail_json(msg="Tunnel configuration must include non-empty 'hosts' key")
    
    try:
        import subprocess
        ansible_result = dict(
            status=200,
            changed=True,
            result=build_config(tunnel, hostvars))
    except Exception as e:
        ansible.fail_json(msg=str(e))

    ansible.exit_json(**ansible_result)


if __name__ == '__main__':
    main()
